/*! circlepacker v1.1.7 | MIT (c) 2023 Georg Fischer <hi@snorpey.com> | https://github.com/snorpey/circlepacker#readme */
function e(e,t,i){"number"!=typeof e&&"number"!=typeof t&&(e=0,t=1),"number"!=typeof t&&(t=e,e=0);let r=e+Math.random()*(t-e);return i&&(r=parseInt(r,10)),r}function t(e){return e&&i(e.id)&&e.radius&&e.position&&"number"==typeof e.position.x&&"number"==typeof e.position.y}function i(e){return"number"==typeof e&&!isNaN(e)||"string"==typeof e&&e.length>0}function r(e,t){return"number"==typeof e&&e>=t}function o(e){return"object"==typeof e&&"number"==typeof e.x&&"number"==typeof e.y}class s{constructor(e){this.worker=new Worker(URL.createObjectURL(new Blob(["class i{constructor(i,s){\"object\"==typeof i?(this.x=i.x,this.y=i.y):(this.x=i,this.y=s)}cp(){return new i(this.x,this.y)}mul(i){return this.x*=i,this.y*=i,this}normalize(){var i=this.length();return this.x/=i,this.y/=i,this}length(){var i=Math.sqrt(this.x*this.x+this.y*this.y);return i<.005&&i>-.005?1e-6:i}distance(i){var s=this.x-i.x,t=this.y-i.y;return Math.sqrt(s*s+t*t)}distanceSquared(i){var s=this.x-i.x,t=this.y-i.y;return s*s+t*t}}class s{constructor({id:s,radius:t,x:e,y:r,isPulledToCenter:n,isPinned:o}){e=e||0,r=r||0,this.id=s,this.targetPosition=new i(0,0),this.position=new i(e,r),this.previousPosition=new i(e,r),this.isPulledToCenter=n,this.isPinned=o,this.setRadius(t)}setPosition(i){this.previousPosition=this.position,this.position=i.cp()}setRadius(i){this.radius=i,this.radiusSquared=i*i}get delta(){return new i(this.position.x-this.previousPosition.x,this.position.y-this.previousPosition.y)}}self.addEventListener(\"message\",(function(s){const e=function(i){return i.data?JSON.parse(i.data):void 0}(s);if(e){const{action:s}=e;switch(s.type){case\"SET_BOUNDS\":t.setBounds(s.bounds);break;case\"SET_CENTERING_PASSES\":t.numberOfCenteringPasses=s.numberOfCenteringPasses;break;case\"SET_COLLISION_PASSES\":t.numberOfCollisionPasses=s.numberOfCollisionPasses;break;case\"SET_DAMPING\":t.damping=s.damping;break;case\"SET_CENTER_PULL\":t.setCenterPull(s.centerPull);break;case\"UPDATE\":t.updatePositions(),o={type:\"MOVED\",updatedCircles:t.allCircles.reduce(((i,s)=>(i[s.id]={id:s.id,position:s.position,previousPosition:s.previousPosition,radius:s.radius,delta:s.delta,isPulledToCenter:s.isPulledToCenter,isPinned:s.isPinned},i)),{})},function(i,s){i.postMessage(JSON.stringify(s))}(self,o);break;case\"ADD_CIRCLES\":n=s.circles,Array.isArray(n)&&n.length&&n.forEach(t.addCircle.bind(t));break;case\"REMOVE_CIRCLE\":t.removeCircle(s.id);break;case\"DRAG_START\":t.dragStart(s.id);break;case\"DRAG_END\":t.dragEnd(s.id);break;case\"DRAG_MOVE\":t.drag(s.id,s.position);break;case\"SET_CIRCLE_RADIUS\":t.setCircleRadius(s.id,s.radius);break;case\"SET_CIRCLE_CENTER_PULL\":t.setCircleCenterPull(s.id,s.centerPull);break;case\"PIN_CIRCLE\":t.pinCircle(s.id);break;case\"UNPIN_CIRCLE\":t.unpinCircle(s.id);break;case\"SET_TARGET\":(r=s.target)&&\"number\"==typeof r.x&&\"number\"==typeof r.y&&t.setTarget(new i(r))}}var r;var n;var o}));const t=new class{constructor(){this.allCircles=[],this.pinnedCircleIds=[],this.desiredTarget=new i(0,0),this.bounds={left:0,top:0,right:0,bottom:0},this.damping=.025,this.numberOfCenteringPasses=1,this.numberOfCollisionPasses=3,this.isCenterPullActive=!0}setBounds(i){\"number\"==typeof i.left&&(this.bounds.left=i.left),\"number\"==typeof i.right&&(this.bounds.right=i.right),\"number\"==typeof i.top&&(this.bounds.top=i.top),\"number\"==typeof i.bottom&&(this.bounds.bottom=i.bottom),\"number\"==typeof i.width&&(this.bounds.right=this.bounds.left+i.width),\"number\"==typeof i.height&&(this.bounds.bottom=this.bounds.top+i.height)}addCircle(i){i instanceof s||(i=new s({id:i.id,radius:i.radius,x:i.position.x||0,y:i.position.y||0,isPinned:i.isPinned||!1,isPulledToCenter:\"boolean\"!=typeof i.isPulledToCenter||i.isPulledToCenter})),this.allCircles.push(i),i.targetPosition=this.desiredTarget.cp()}removeCircle(i){this.allCircles.filter((s=>s.id===i)),this.allCircles=this.allCircles.filter((s=>s.id!==i))}updatePositions(){const i=this.allCircles,s=i.length;for(let t=0;t<s;++t){const s=i[t];s.previousPosition=s.position.cp()}this.desiredTarget&&this.isCenterPullActive&&this.pushAllCirclesTowardTarget(this.desiredTarget),this.handleCollisions();for(let t=0;t<s;++t){const s=i[t];this.handleBoundaryForCircle(s)}}pushAllCirclesTowardTarget(s){const t=new i(0,0),e=this.draggedCircle,r=this.allCircles,n=r.length;for(let i=0;i<this.numberOfCenteringPasses;i++)for(let i=0;i<n;i++){const n=r[i];if(n.isPulledToCenter){if(n===e||this.isCirclePinned(n.id))continue;t.x=n.position.x-s.x,t.y=n.position.y-s.y,t.mul(this.damping),n.position.x-=t.x,n.position.y-=t.y}}}handleCollisions(){const s=new i(0,0),t=this.draggedCircle,e=this.allCircles,r=e.length;for(let i=0;i<this.numberOfCollisionPasses;i++)for(let i=0;i<r;i++){var n=e[i];for(let l=i+1;l<r;l++){var o=e[l];const i=this.isCirclePinned(n.id),r=this.isCirclePinned(o.id),d=n===t||i,a=o===t||r;if(n===o||d&&a)continue;const h=o.position.x-n.position.x,c=o.position.y-n.position.y,u=1.08*(n.radius+o.radius),C=n.position.distanceSquared(o.position);if(C<u*u-.02){s.x=h,s.y=c,s.normalize();const i=.5*(u-Math.sqrt(C));s.mul(i),a||(d&&s.mul(2.2),o.position.x+=s.x,o.position.y+=s.y),d||(a&&s.mul(2.2),n.position.x-=s.x,n.position.y-=s.y)}}}}handleBoundaryForCircle(i){const s=i.position.x,t=i.position.y,e=i.radius;let r=!1;s+e>=this.bounds.right?(i.position.x=this.bounds.right-e,r=!0):s-e<this.bounds.left&&(i.position.x=this.bounds.left+e,r=!0),t+e>this.bounds.bottom?(i.position.y=this.bounds.bottom-e,r=!0):t-e<this.bounds.top&&(i.position.y=this.bounds.top+e,r=!0),r&&i===this.draggedCircle&&(this.draggedCircle=null)}setDraggedCircle(i){this.draggedCircle=i}dragStart(i){const s=this.allCircles.filter((s=>s.id===i))[0];this.setDraggedCircle(s)}dragEnd(){this.draggedCircle&&(this.draggedCircle=null)}drag(i,s){this.draggedCircle&&s&&(this.draggedCircle.position.x=s.x,this.draggedCircle.position.y=s.y)}isCirclePinned(i){const s=this.circleById(i);return!!s&&s.isPinned}pinCircle(i){const s=this.circleById(i);s&&(s.isPinned=!0)}unpinCircle(i){const s=this.circleById(i);s&&(s.isPinned=!1)}setCircleRadius(i,s){const t=this.circleById(i);t&&t.setRadius(s)}setCircleCenterPull(i,s){const t=this.circleById(i);t&&(t.isPulledToCenter=s)}setCenterPull(i){this.isCenterPullActive=i}circleById(i){return this.allCircles.filter((s=>s.id===i))[0]}setTarget(i){this.desiredTarget=i}};\n"],{type:'text/javascript'}))),this.worker.addEventListener("message",this.receivedWorkerMessage.bind(this)),this.isContinuousModeActive="boolean"!=typeof e.continuousMode||e.continuousMode,this.onMoveStart=e.onMoveStart||null,this.onMove=e.onMove||null,this.onMoveEnd=e.onMoveEnd||null,this.lastCirclePositions=[],e.centeringPasses&&this.setCenteringPasses(e.centeringPasses),e.collisionPasses&&this.setCollisionPasses(e.collisionPasses),this.addCircles(e.circles||[]),this.setBounds(e.bounds||{width:100,height:100}),this.setTarget(e.target||{x:50,y:50}),this.isLooping=!1,this.areItemsMoving=!0,this.animationFrameId=NaN,this.initialized=!0,this.isContinuousModeActive&&this.startLoop()}receivedWorkerMessage(e){const t=function(e){return e.data?JSON.parse(e.data):void 0}(e);if("MOVED"===t.type){const e=t.updatedCircles;this.areItemsMoving=this.hasItemMoved(e),!this.areItemsMoving&&this.isLooping&&this.initialized&&this.isContinuousModeActive&&this.stopLoop()}this.updateListeners(t)}updateWorker(t){var i,r;i=this.worker,r={messageId:Date.now()+e(0,.001,!0),action:t},i.postMessage(JSON.stringify(r))}updateListeners(e){"MOVE_START"===e.type&&"function"==typeof this.onMoveStart&&this.onMoveStart(),"MOVED"===e.type&&"function"==typeof this.onMove&&(this.lastCirclePositions=e.updatedCircles,this.onMove(e.updatedCircles)),"MOVE_END"===e.type&&"function"==typeof this.onMoveEnd&&this.onMoveEnd(e.updatedCircles)}addCircles(e){if(!Array.isArray(e))throw new Error("Can't add circles: the circles parameter is not an array.");if(e.length){if(!e.every(t))throw new Error("Can't add circles: some of the items are not well formatted.");this.updateWorker({type:"ADD_CIRCLES",circles:e}),this.startLoop()}}addCircle(e){this.addCircles([e])}removeCircle(e){const t="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(t))throw new Error("Can't remove circle: the circleRef parameter is malformed.");this.updateWorker({type:"REMOVE_CIRCLE",id:t}),this.startLoop()}pinCircle(e){const t="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(t))throw new Error("Can't pin circle: the circleRef parameter is malformed.");this.updateWorker({type:"PIN_CIRCLE",id:t}),this.startLoop()}unpinCircle(e){const t="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(t))throw new Error("Can't unpin circle: the circleRef parameter is malformed.");this.updateWorker({type:"UNPIN_CIRCLE",id:t}),this.startLoop()}setCircleRadius(e,t){const o="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(o))throw new Error("Can't set circle radius: the circleRef parameter is malformed.");if(!r(t,0))throw new Error("Can't set circle radius: the passed radius is malformed.");this.updateWorker({type:"SET_CIRCLE_RADIUS",id:o,radius:t}),this.startLoop()}setCircleCenterPull(e,t){const r="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(r))throw new Error("Can't set circle center pull: the circleRef parameter is malformed.");this.updateWorker({type:"SET_CIRCLE_CENTER_PULL",id:r,centerPull:!!t}),this.startLoop()}setCenterPull(e){this.updateWorker({type:"SET_CENTER_PULL",centerPull:!!e}),this.startLoop()}setBounds(e){if(!function(e){return"object"==typeof e&&"number"==typeof e.width&&"number"==typeof e.height}(e))throw new Error("Can't set bounds: the bounds parameter is malformed.");this.updateWorker({type:"SET_BOUNDS",bounds:e}),this.startLoop()}setTarget(e){if(!o(e))throw new Error("Can't set target: the targetPos parameter is malformed.");this.updateWorker({type:"SET_TARGET",target:e}),this.startLoop()}setCenteringPasses(e){if(!r(e,1))throw new Error("Can't set centering passes: the numberOfCenteringPasses parameter is malformed.");this.updateWorker({type:"SET_CENTERING_PASSES",numberOfCenteringPasses:e})}setCollisionPasses(e){if(!r(e,1))throw new Error("Can't set collisionPasses passes: the numberOfCollisionPasses parameter is malformed.");this.updateWorker({type:"SET_COLLISION_PASSES",numberOfCollisionPasses:e})}setDamping(e){if(!("number"==typeof e&&e>0&&e<1))throw new Error("Can't set damping: the damping parameter is malformed.");this.updateWorker({type:"SET_DAMPING",damping:e})}update(){this.updateWorker({type:"UPDATE"})}dragStart(e){const t="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(t))throw new Error("Can't start dragging circle: the circleRef parameter is malformed.");this.updateWorker({type:"DRAG_START",id:t}),this.startLoop()}drag(e,t){const r="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(r))throw new Error("Can't drag circle: the circleRef parameter is malformed.");if(!o(t))throw new Error("Can't drag circle: the position parameter is malformed.");this.updateWorker({type:"DRAG_MOVE",id:r,position:t}),this.startLoop()}dragEnd(e){const t="object"==typeof e&&void 0!==e.id?e.id:e;if(!i(t))throw new Error("Can't end dragging circle: the circleRef parameter is malformed.");this.updateWorker({type:"DRAG_END",id:t}),this.startLoop()}updateLoop(){this.update(),this.isLooping&&(this.areItemsMoving?this.animationFrameId=requestAnimationFrame((()=>this.updateLoop())):this.stopLoop())}startLoop(){!this.isLooping&&this.initialized&&this.isContinuousModeActive&&(this.isLooping=!0,this.isContinuousModeActive&&(this.areItemsMoving=!0),this.updateListeners({type:"MOVE_START"}),this.animationFrameId=requestAnimationFrame((()=>this.updateLoop())))}stopLoop(){this.isLooping&&(this.isLooping=!1,this.updateListeners({type:"MOVE_END",updatedCircles:this.lastCirclePositions}),cancelAnimationFrame(this.animationFrameId))}hasItemMoved(e){let t=!1;for(let i in e)(Math.abs(e[i].delta.x)>.005||Math.abs(e[i].delta.y)>.005)&&(t=!0);return t}destroy(){this.worker&&this.worker.terminate(),this.stopLoop(),this.onMove=null,this.onMoveStart=null,this.onMoveEnd=null}}export{s as default};
